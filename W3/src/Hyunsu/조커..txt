1. 입력 받은 배열을 오름차순으로 정렬 : list_pre
***cnt = 0의 갯수
2. 중복되는 숫자들을 제거해서 : list_final

{3, 5, 6, 10, 11, 0, 0} 일 때.
list_final[idx+j]-list_final[idx] -1 = 5-3-1 = 1(개의 숫자 또는 0으로 채워줘야할 needs)
(idx+j)-(idx) -1 = 1-0-1=0 : 배열에서 3과 5 사이에 있는 숫자의 갯수. 둘 사이에는 숫자가 없음. = already.
needs 와 (already + cnt) 를 비교하면 크게 3가지 경우로 나올 수 있다

- 모든 배열의 입력이 0일 경우는 0의 갯수=최대연속길이 반환

- (=) 필요한 숫자(또는 0의 갯수) 와 사이의 숫자와 0의 갯수가 일치
		- 현재 연속 숫자의 길이 : tmp = list_final[idx+j]-list_final[idx] + 1

- (>) 필요한 숫자가 더 많을 때, 0이 부족
		- 다음 i로 가야함 
		- break;
- (<) 더 많은 숫자가 있을 경우
		- 마지막 인덱스가 아닐 경우, 다음 j로 넘어감
			- 현재 연속 숫자의 길이 : tmp = list_final[idx+j]-list_final[idx] + 1
			- 3,5 = > 5-3+1 = 길이가 3
			- 현재 길이 + 남은 0의 갯수(뒤에 0을 붙이면 연장할 수 있다.)
			- tmp = 현재 길이 + 남은 0의 갯수
			- tmp와 max 비교.
			
			- 다음 j로 감.
			
			
		- 마지막 인덱스일 경우, 남은 0의 갯수를 현 길이에 더해줌.
			- 현재 연속 숫자의 길이 : tmp = list_final[idx+j]-list_final[idx] + 1
			
			  <남은 0의 갯수>
			- (already + cnt) - needs : 이미 존재하는 숫자와 0의 갯수 - 필요했던 수 = 남는 0의 갯수
			
			- tmp = 현재 길이 + 남은 0의 갯수
			- tmp와 max 비교.
